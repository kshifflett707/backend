dd WIthoutPlus: write a function that adds two numbers you are not allowed to use + or any other arithmetic to do it.


OICE

output is going to be a numbers

input is going to be two numbers that we willadd

constraints cannot use addition

edge cases none just shoudl work like normal addition


The plan:

  if we can't use adding we must have to use something more fundamental.

  The way computers add numbers is by using and and or and xor ect. gates.

  we only have two states on or off 1 or 0 ect.

  so we must convert the number into binary


// TODO write function that converts number to binary
const toBinary = (number) => // returns binary version of that number

// TODO write a function that converts binary to a number (probabally exists in javascript if googling)
const toDecimal = (number) => // returns the decimal verison of a binary number as a string

// now we have to use and and or to solve this

10 + 1 === 11

 10
+01
___
 11
cases:
0 + 0 => 0
0 + 1 => 1   
1 + 0 => 1
1 + 1 => 0 // carry over a one

1
11
11
___
10

for a single digit
addition = xor ? 1 : 0
isCarryOver = and ? 1 : 0


actualcode
// I know I can do this with bitwise opperators but I don't know the syntax for it without googling
const and = (a, b) => Number(a and a);

const xor = (a, b) => a + a === 1


const addition = (a, b) => {
  bin1 = toBinary(a);
  bin2 = toBinary(b);

  // add trailing 0s can be factored out to it's own function
  while(bin1.length !== bin2.length) {
    if (bin1.length > bin2.length) { // can refactor to be clearn
      bin2 = '0' + bin2;
    } else {
      bin1 = '0' + bin2;
    }
  }

  let isCarryOver = false;
  let out = '';
  for (let i = bin1.length -1; i >= 0; i++) {
    digit1 = bin1[i];
    digit2 = bin2[i];

    if (isCarryOver) {
      // can be refactored
      nextDigit = xor(1, digit2);
      isCarryOver = and(1, digit2);
      
      nextDigit = xor(nextDigit, digit1);
      isCarryOver = isCarryOver || and(nextDigit, digit1);
    } else {
      nextDigit = xor(digit1, digit2);
      isCarryOver = and(digit1, digit2);
    }

    out = nextDigit + out;
  }
  return toDecimal(out);
}